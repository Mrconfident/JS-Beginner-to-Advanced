<script>
  // let user = {
  //   name: 'tarun',
  //   email: 't@gmail.com',
  //   location: 'Bnglr',
  //   blogs: [1,2,4],
  //   // login: function () {
  //   //   console.log('LoggedIn')
  //   // },
  //   details: function () {
  //     console.log(user)
  //   },
  //   checkThis: function () {
  //     console.log(this)
  //   },
  //   getName: function () {
  //     console.log(this.name)
  //   },
  //   rollNo: 43
  // }
//   user.education = 'Btech'
//   console.log(user)
//   user.check = function () {
//     console.log(this)
//   }
//   user.check()
// //   user = {
// //   login() { // same as "login: function(){...}"
// //     alert("Hello")
// //   }
// // }
// //   console.log(user)
// // // user.check = function () {
// // //   console.log(this)
// // // }
// user.rCheck = () => {
//   console.log(this)
// }
// // // user.check()
// user.rCheck()

// // The value of this is evaluated during the run-time, depending on the context.
// // };
//   // user.login()
//   // user.details()
//   // user.checkThis()
//   // user.getName()


  // shallow copy and deep copy
//   const car = {
//     name: 'Ford',
//     color: 'red',
//     type: 'SUV',
//     variant: 1222
//   }

// //   // delete car.variant
// console.log(car)

// const vehicle = car  // shallow copy ,not good
// // console.log(vehicle)
// //   // console.log(car)

// // vehicle.name = 'Mustang'
// //   console.log(vehicle)
// //   console.log(car)

// //   // console.log(JSON.stringify(car))
// const veh = JSON.parse(JSON.stringify(car)) // deep copy

// veh.name = 'Range Rover'
//   console.log('Veh' ,veh)
//   console.log('Car', car)


// //   Write the code, one line for each action:

// // Create an empty object user.
// // Add the property name with the value John.
// // Add the property surname with the value Smith.
// // Change the value of the name to Pete.
// // Remove the property name from the object.

// //Here the function makeUser returns an object.
// //What is the result of accessing its ref? Why?

// // function makeUser() {
// //   return {
// //     name: "John",
// //     ref: this
// //   };
// // }

// // let user11 = makeUser();

// // console.log( user11.ref.name );

// const x = {};

// x.foo = 'bar';

// console.log(x) // {foo : 'bar'} // because we are not reassigning the object itself

// x.foo = 'bar2'

// console.log(x);

// x = {foo: 'bar'}
// console.log(x) // this is reassignment

// // Cloning and merging

const main = {
  name: "John",
  age: 30
}

// const clone = {};

// for(let x in main) {
//   clone[x] = main[x]
// }

// clone.name = 'Tarun'

// console.log(clone)
// console.log(main)

// // Object.assign
// // Object.assign(targetObject, srcObject1, srcObject2, .....) syntax

// const assign = {
//   color: 'black'
// }

// const assign2 = {
//   color: 'red',
//   mobile: 'Iphone'
// }

// const assign3 = {
//   ram: '2GB',
//   rom: '16GB'
// }

// // if copied object property is there in the target , then its get OverWrittened

// // Optional Chaining

// // The optional chaining ?. stops the evaluation if the value before ?. is undefined or null and returns undefined.

let tag = "firstName";

let user1 = {
  firstName: "John"
};

let user2 = undefined;
console.log( user2?.A); 
// alert( user2?.[key] ); // undefined


// // Destructuring the Objects
// const obj = { };
// const { a = null } = obj;  // destructing
// console.log(a)

// const { a, ...others } = { a: 1, b: 2, c: 3, d:4};
// console.log(a)
// console.log(others)
// is equivalent to:
// const e = obj.a;
// console.log(e)
// // const b = obj.b;

// console.log(a)
// console.log(b)
// console.log(obj.a)
// console.log(obj.b)

// Default Values while Destructuring
// const [a = 1] = []; // a is 1
// const { b = 2 } = { b: undefined }; // b is 2
// const { c = 2 } = { c: null }; // c is null


// Rest property: will store all remaining properties of the object or array into a new object or array.
// 
// console.log(others); // { b: 2, c: 3 }

// const [v, ...others2] = [1, 2, 3];
// console.log(others2); // [2, 3]

</script>